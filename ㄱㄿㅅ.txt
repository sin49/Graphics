API(Application Programming Interface):프로그램 작성을 하기위한 인터페이스
인터페이스(not클레스): 상호작용을 할수있게 하는 거
인터페이스(클레스): 클레스를 사전에 설계해둔 가상의 형태


API(Application Programming interface):

객체 
win32 데스크톱:
Hmenu:핸들러 중 하나()
핸들러:이벤트를 제어하는 기능
이벤트:상태가 달라지는거
콜백함수: 특정 이벤트에서 호출하는 함수 (플랫폼에서 처리),함수의 주소를 플랫폼에 넘겨서 특정 타이밍에 플랫폼이 그 주소의 함수를 실행(이것도 포인터,델리게이트?)
메세지:프로그램 상태를 보내주는거
WM_Create:시작할 때
wm_Command:이벤트
wm_paint:Trydraw
wm_destroy:Tryquit

플랫폼:,운영체제,SDK....프로그램을 실행하는 환경?(PC,콘솔,Mobile)

콘솔:특정 프로그램 실행을 위한 플랫폼?
크로스플랫폼:다른 플랫폼에서도 똑같이 작동하는 거
빌드:플랫폼에 맞게 프로젝트를 최적으로 정리(컴파일)

클라우드:서비스 중에 과정,결과 ㅇㅃㄴ

백도어:우회로


동적 바인딩:실행 중에 함수의 기능 설정//오버라이딩
정적 바인딩:프로그램 실행 전에 함수의 기능 설정

Dll:
MFC(Microsoft Foundation Class):win32와 다르게 객체 지향 프로그래밍
Cobject기반의 객체를 통해 제작

프로세스:컴퓨터가 실행하는 과정
스레드:프로세스 내부의 실행 단위


SDL: 소프트 웨어 보안 검사(끄면 보안 이슈로 크리티컬->보안이 중요한 경우 예)

void 포인터: 타입 없는 포인터( c 문법 malloc)

타입에 따라 소프트웨어가 크기에 맞게 주소 할당

변수가 표현범위가 있는 이유:이진수로 매핑됨
정해진 표현 범위를 초과하면 오버.언더 플로우

long pointer:32비트의 포인터
메모리난독화:메모리를 다른 이용자가 알아볼수없는형태로 만들기
시리얼라이즈:직렬화
동적할당:Cpu에서 그때그때 필요한 메모리를 받기
정적할당:실행전에 미리 몇몇 메모리를 디스크에서 받기
메모리누수:동적할당된 메모리를 반환하지 않고 계속 리소스 먹는 상태
메모리페이징:메모리 사이에 빈공간이 발생해 메모리 할당이 불가능한 상태


Task Thread 차이:Thread 하드웨어를 갈굼
Task는 잡스케쥴러를 써서 하드웨어를 안 갈굼
잡스케쥴러:task의 작업을 받아서 코어에서 알맞게 분배(큐잉과 비슷함)
cput 스레드처리:
듀얼코어게임처리:
멀티코어게임처리:
오버헤드:
컨텍스트스위칭:
--------------------------------------------

MFC(Microsoft Foundation Class): 윈도우 이해용 MFC 간단 찍먹 해보기(c#배울때 해본적 있는거 같은디):
https://onedrive.live.com/view.aspx?resid=6D16D8E1C579A2A2%21187154&authkey=!AM5MMAgPN2sKwZM

윈도


크로플랫플러그인
네이티브플러그인
안드로이드스튜디오:

비동기:

다렉:만들어진 걸로 몇가지 해보는거(opengl?)
https://onedrive.live.com/view.aspx?resid=6D16D8E1C579A2A2%21187188&authkey=!AM5tvfXHE_Rh-RY




프로젝트 winapi 스레드 예제 큐잉 처리
